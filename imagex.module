<?php
/**
 * @file
 */

/**
 * Denotes that the environment is in development mode.
 */
define('IMAGEX_MODE_DEVELOPMENT', 1);

/**
 * Denotes that the environment is in staging mode.
 */
define('IMAGEX_MODE_STAGING', 2);

/**
 * Denotes that the environment is in production mode.
 */
define('IMAGEX_MODE_PRODUCTION', 3);

/**
 * Defines the watchdog type of ImageX.
 */
define('IMAGEX_WATCHDOG_TYPE', 'imagex');

/**
 * Defines the major version of Drupal core.
 */
define('IMAGEX_CORE_MAJOR_VERSION', '7.x');

/**
 * Returns the current operating mode of ImageX install profile.
 *
 * @return int
 *   Returns the current operating mode.
 */
function imagex_mode() {
  return variable_get('imagex_mode', imagex_default_mode());
}

/**
 * Returns a boolean to determine if the current mode is development.
 * 
 * @return boolean
 *   Returns TRUE if the current mode is development, otherwise FALSE.
 */
function imagex_mode_is_development() {
  return IMAGEX_MODE_PRODUCTION == imagex_mode();
}

/**
 * Returns a boolean to determine if the current mode is staging.
 * 
 * @return boolean
 *   Returns TRUE if the current mode is staging, otherwise FALSE.
 */
function imagex_mode_is_staging() {
  return IMAGEX_MODE_STAGING == imagex_mode();
}

/**
 * Returns a boolean to determine if the current mode is production.
 * 
 * @return boolean
 *   Returns TRUE if the current mode is production, otherwise FALSE.
 */
function imagex_mode_is_production() {
  return IMAGEX_MODE_PRODUCTION == imagex_mode();
}

/**
 * Changes the current operating mode.
 * 
 * @param int $mode
 *   The current operating mode. Use one of the IMAGEX_MODE_ constants.
 */
function imagex_mode_set($mode) {
  if (!imagex_mode_is_valid($mode)) {
    watchdog(IMAGEX_WATCHDOG_TYPE, 'Attempted to set an invalid mode, %mode.', array('%mode' => $mode), WATCHDOG_DEBUG);
    return;
  }

  variable_set('imagex_mode', $mode);
  foreach (module_implements('imagex_mode_changed') as $module) {
    module_invoke($module, 'imagex_mode_changed', $mode);
  }
}

/**
 * Returns a boolean to determine whether or not the mode is a valid mode.
 * 
 * @param int $mode
 *   An operating mode to change to.
 *
 * @return boolean
 *   Returns TRUE if $mode is valid, otherwise FALSE.
 */
function imagex_mode_is_valid($mode) {
  switch ($mode) {
    case IMAGEX_MODE_PRODUCTION:
    case IMAGEX_MODE_STAGING:
    case IMAGEX_MODE_DEVELOPMENT:
      return TRUE;
  }

  return FALSE;
}

/**
 * Returns either an array or string representation for mode languages.
 *
 * @param mixed $mode
 *   The mode to return its string representation for. If NULL, an array
 *   of all mode language representations are returned.
 *
 * @return mixed
 *   Returns either a string or an array.
 */
function imagex_mode_language($mode = NULL) {
  static $languages = NULL;

  if (NULL === $languages) {
    $languages =  array(
      IMAGEX_MODE_DEVELOPMENT => t('development'),
      IMAGEX_MODE_STAGING => t('staging'),
      IMAGEX_MODE_PRODUCTION => t('production'),
    );
  }

  if (NULL !== $mode && isset($languages[$mode])) {
    return $languages[$mode];
  }

  return $languages;
}

/**
 * Returns the default operating mode.
 *
 * @return int
 *   Returns the IMAGEX_MODE_PRODUCTION value.
 */
function imagex_mode_default() {
  return IMAGEX_MODE_PRODUCTION;
}

/**
 * Returns the an array of default variables for the ImageX profile.
 *
 * @return array
 *   Returns variable and default value map array.
 */
function imagex_imagex_variables() {
  return array(
    'imagex_mode' => imagex_mode_default(),
  );
}

/**
 * Retrieves and returns the a configuration file path for modules.
 *
 * Helper function will initially look in the current site's directory where
 * the settings.php file lives. If the file is not found within the sites/* 
 * directory, the sites/default/ will be used as a failsafe. Finally, if neither
 * the current site's directory or sites/default/ has the file living within it,
 * the specified `$module` base directory will be used.
 *
 * Current implementation is derived from Drupal's `conf_path` function.
 * 
 * @see http://api.drupal.org/api/drupal/includes!bootstrap.inc/function/conf_path/7
 * 
 * @param string $module
 *   The name of the module that the file is associated with.
 * @param string $filename
 *   The filename including extension.
 * @param bool $reset
 *   A boolean value used to indicate if the current value should be reset.
 *
 * @return mixed
 *   Returns the absolute file path as a string if found, otherwise FALSE.
 */
function imagex_conf_path($module, $filename, $reset = FALSE) {
  $conf = &drupal_static(__FUNCTION__, array());
  if (isset($conf[$filename]) && !$reset) {
    return $conf[$filename];
  }

  $confdir = 'sites';
  $sites = array();
  if (file_exists(DRUPAL_ROOT . '/' . $confdir . '/sites.php')) {
    include DRUPAL_ROOT . '/' . $confdir . '/sites.php';
  }

  $uri = explode('/', $_SERVER['SCRIPT_NAME'] ? $_SERVER['SCRIPT_NAME'] : $_SERVER['SCRIPT_FILENAME']);
  $server = explode('.', implode('.', array_reverse(explode(':', rtrim($_SERVER['HTTP_HOST'], '.')))));
  for ($i = count($uri) - 1; $i != 0; $i--) {
    for($j = count($server); $j != 0; $j--) {
      $dir = implode('.', array_slice($server, -$j)) . implode('.', array_slice($uri, 0, $i));
      if (isset($sites[$dir]) && file_exists(DRUPAL_ROOT . '/' . $confdir . '/' . $sites[$dir])) {
        $dir = $sites[$dir];
      }

      if (file_exists(DRUPAL_ROOT . '/' . $confdir . '/' . $dir . '/' . $filename)) {
        $conf[$filename] = $confdir . '/' . $dir . '/' . $filename;
        return $conf[$filename];
      }
    }
  }

  if (file_exists(DRUPAL_ROOT . '/' . $confdir . '/default/' . $filename)) {
    $conf[$filename] = $confdir . '/default/' . $filename;
    return $conf[$filename];
  }

  if ($module_path = drupal_get_path('module', $module)) {
    if (file_exists(DRUPAL_ROOT . '/' . $module_path . '/' . $filename)) {
      $conf[$filename] = DRUPAL_ROOT . '/' . $module_path . '/' . $filename;
      return $conf[$filename];
    }
  }

  return FALSE;
}

/**
 * Returns the current major version of a module based on its .info version.
 * 
 * @param string $module_name
 *   The module name to retrieve the major version for.
 *
 * @return mixed
 *   Returns a string representing the major version, else returns FALSE
 *   if the major version does not exist and or if the module does not exist.
 */
function imagex_get_module_major_version($module_name) {
  // Test and ensure that the module actually exists.
  if (!module_exists($module_name)) {
    return FALSE;
  }

  // Attempt to resolve and load the module's .info file information.
  $module_path = drupal_get_path('module', $module_name);
  $module_info = drupal_parse_info_file($module_path . '/' . $module_name . '.info');

  // If the info file was loaded, let's hope the `version` is specified.
  if (!empty($module_info) && isset($module_info['version'])) {
    $module_version = $module_info['version'];
    // Retrieve and determine the core version.
    $module_core_version = (isset($module_info['core']) ? ($module_info['core']) : IMAGEX_CORE_MAJOR_VERSION) . '-';
    // Remove the core version and explode based on separator (.).
    $module_version = str_replace($module_core_version, '', $module_version);
    $module_version = explode('.', $module_version);
    // The major version is at offset zero, therefore just shift it off.
    $module_version = array_shift($module_version);
    // array_shift will return NULL if the $module_version is empty, therefore
    // simply check and return FALSE, otherwise the major version.
    return NULL !== $module_version ? $module_version : FALSE;
  }
  return FALSE;
}

/**
 * Implements hook_modules_installed().
 */
function imagex_modules_installed($modules) {
  foreach ($modules as $module) {
    _imagex_variables_set_for($module);
  }
}

/**
 * Implements hook_modules_uninstalled().
 */
function imagex_modules_uninstalled($modules) {
  foreach ($modules as $module) {
    _imagex_variables_delete_for($module);
  }
}

/**
 * Rebuilds the variables for modules implementing hook_imagex_variables().
 */
function imagex_variables_rebuild() {
  foreach (module_implements('imagex_variables') as $module) {
    _imagex_variables_set_for($module);
  }
}

/**
 * Removes the variables for modules implementing hook_imagex_variables().
 */
function imagex_variables_delete() {
  foreach (module_implements('imagex_variables') as $module) {
    _imagex_variables_delete_for($module);
  }
}

/**
 * Handles the setting of variables for a single module.
 *
 * @param string $module
 *   The name of the module to set variables for.
 */
function _imagex_variables_set_for($module) {
  if (module_hook($module, 'imagex_variables')) {
    $variables = module_invoke($module, 'imagex_variables');
    if (is_array($variables)) {
      _imagex_variables_set($variables);
    }
  }
}

/**
 * Sets an array of variables and default values.
 *
 * @param array $variables
 *   A keyed array of $variable => $value for variables to set.
 *
 * @return bool
 *   Returns TRUE if success, otherwise FALSE.
 */
function _imagex_variables_set(array $variables = array()) {
  if (!empty($variables)) {
    foreach ($variables as $variable => $default) {
      variable_set($variable, $default);
    }
    return TRUE;
  }
  return FALSE;
}

/**
 * Handles the deletion of variables for a single module.
 *
 * @param $module
 *   The name of the module to delete variables for.
 */
function _imagex_variables_delete_for($module) {
  if (module_hook($module, 'imagex_variables')) {
    $variables = module_invoke($module, 'imagex_variables');
    if (is_array($variables)) {
      $variables = array_keys($variables);
      _imagex_variables_delete($variables);
    }
  }
}

/**
 * Removes an array of variables.
 *
 * @param array $variables
 *   An array of variable names to delete.
 *
 * @return bool
 *   Returns TRUE if success, otherwise FALSE.
 */
function _imagex_variables_delete(array $variables = array()) {
  if (!empty($variables)) {
    foreach ($variables as $variable) {
      variable_del($variable);
    }
    return TRUE;
  }
  return FALSE;
}

/**
 * Returns a boolean to determine if we are currently in the install.
 *
 * @return bool
 *   Returns TRUE if currently in the middle of a Drupal core installation,
 *   otherwise returns FALSE.
 */
function imagex_drupal_is_installing() {
  return 'done' == variable_get('install_task', NULL) ? TRUE : FALSE;
}
